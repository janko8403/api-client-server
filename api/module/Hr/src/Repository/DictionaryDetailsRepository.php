<?php

namespace Hr\Repository;

use Commissions\Entity\Questionnaire;
use Hr\Entity\Dictionary;
use Hr\Entity\DictionaryDetails;

/**
 * DictionaryDetailsRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class DictionaryDetailsRepository extends \Doctrine\ORM\EntityRepository
{
    public function getDetailsForDictionary($key)
    {
        $qb = $this->createQueryBuilder('dd');
        $qb->innerJoin('dd.dictionary', 'd');
        $qb->andWhere('d.key = :key')->setParameter('key', $key);
        $qb->orderBy('dd.name');

        return $qb->getQuery()->execute();
    }

    public function autocompleteSearch($dictionaryId, $term, $searchById = false)
    {
        $qb = $this->createQueryBuilder('d');
        $qb->andWhere($qb->expr()->eq('d.dictionary', $dictionaryId));

        if ($searchById) {
            $qb->andWhere($qb->expr()->eq('d.id', $term));
        } else {
            $qb->andWhere('d.name LIKE :name')
                ->setParameter('name', "$term%");
        }
        $qb->orderBy('d.name');
        $qb->andWhere('d.isactive = 1');
        $qb->setMaxResults(10);

        $tmp = [];
        $data = $qb->getQuery()->execute();
        foreach ($data as $d) {
            $tmp[] = ['id' => $d->getId(), 'text' => $d->getName()];
        }

        return $tmp;
    }

    public function getStreetPrefix()
    {
        $qb = $this->createQueryBuilder('d');
        $qb->select('d.name');
        $qb->andWhere('d.dictionary = :dictionary')->setParameter('dictionary', Dictionary::DIC_STREET_PREFIXES);
        $qb->andWhere('d.isactive = 1');
        $qb->andWhere("d.name != ''");
        $result = $qb->getQuery()->execute();

        $data = [];
        foreach ($result as $r) {
            $data[$r['name']] = $r['name'];
        }

        return $data;
    }

    public function getAglomerations($params = null)
    {
        $qb = $this->createQueryBuilder('dd');
        $qb->andWhere(
            $qb->expr()->in('dd.key', Questionnaire::REGION_AGGLOMERATIONS)
        );
        $qb->orderBy('dd.name', 'asc');

        return $qb->getQuery()->execute();
    }

    public function getAgglomerationDict(): array
    {
        $agglomerations = $this->getAglomerations();
        $tmp = [];

        foreach ($agglomerations as $agglomeration) {
            $tmp[$agglomeration->getId()] = $agglomeration->getName();
        }

        return $tmp;
    }

    public function getMacroregionForRegion(int $regionId): array
    {
        $sql = <<<SQL
select dd2.*
from dictionaryDetails dd
join regionSubregionJoint rsj on dd.id = rsj.regionDicId
join subregionMacroregionJoint smj on smj.subregionDicId = rsj.subregionDicId
join dictionaryDetails dd2 on smj.macroregionDicId = dd2.id
where dd.id = :id
SQL;
        $stmt = $this->_em->getConnection()->prepare($sql);
        $stmt->execute(['id' => $regionId]);

        return $stmt->fetchAll();
    }
}
